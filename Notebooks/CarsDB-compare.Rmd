---
jupyter:
  jupytext:
    formats: ipynb,Rmd
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.1'
      jupytext_version: 1.2.1
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

# Compare results in the DB

```{python}
## To autoreload codein python files here.
# %load_ext autoreload
# %autoreload 2

## Add %%black at the top of a cell, and re-evaluate it, 
# to format it before git-commits, and ease diffs.
# %load_ext blackcellmagic
```

```{python}
# %matplotlib ipympl
```

```{python}
from typing import Union, List, Callable, Any, Sequence as Seq
import io, logging, re, sys
from pathlib import Path, PurePosixPath as P


from columnize import columnize
import numpy as np
import pandas as pd
from pandas import HDFStore
from pandas.core.generic import NDFrame
from matplotlib import pyplot as plt
import qgrid
import wltp
from wltp import io as wio, cycler
from wltp.experiment import Experiment

## Add tests/ into `sys.path` to import `vehdb` module.
#
proj_dir = str(Path(wltp.__file__).parents[1] / "tests")
if proj_dir not in sys.path:
    sys.path.insert(0, proj_dir)

import vehdb

idx = pd.IndexSlice
log = logging.getLogger("CarsDB-compare.ipynb")
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s|%(levelname)4.4s|%(module)s:[%(funcName)s]:\n  +--> %(message)s",
    datefmt="%Y-%m-%d,%H:%M:%S",
)

pd.set_option("display.max_columns", 32)
```

```{python}
vehdb.grid(pd.DataFrame([1,2]))
```

```{python}
## DEFINITIONS
#
inp_h5fname = 'VehData/WltpGS-msaccess.h5'
out_h5fname = 'VehData/WltpGS-pyalgo.h5'
c_n, c_p, c_n_norm, c_p_norm = 'n', 'Pwot', 'n_norm', 'p_norm'
```

```{python}
vehdb.print_nodes(inp_h5fname)
vehdb.print_nodes(out_h5fname)
```

```{python}
from wltp.invariants import vround, nround1

def load_accdb_and_python_datasets(veh_nums=None):
    p1, c1 = vehdb.merge_db_vehicle_subgroups(inp_h5fname, "prop", "cycle", veh_nums=veh_nums)
    p2, c2 = vehdb.merge_db_vehicle_subgroups(out_h5fname, "oprop", "cycle", veh_nums=veh_nums)

    ## Originally fetched as 2-levels (veh, item) MultiIndex Series.
    p1 = p1.unstack(); p2 = p2.unstack()
    
    ## By the spec, V rounded to 2-digits,
    #  But exporting MSAccess --> Excel outputs garbage decimals!
    #
    v_cols = "v v_orig v_cap v_downscale".split()
    c1[v_cols] = vround(c1[v_cols])

    ## accdb does not oofer `n_max`.(?)
    p1['n_max'] = nround1(p1['n_max1 n_max2 n_max3'.split()].max(axis=1))
    
    return p1, c1, p2, c2

p1, c1, p2, c2 = load_accdb_and_python_datasets()
```

```{python}
# Available PROPs
print(columnize(list(p1.columns), displaywidth=160))
print(columnize(list(p2.columns), displaywidth=160))
```

```{python}
display(
    vehdb.grid(p1),
    vehdb.grid(p2),
    #vehdb.grid(c1, fitcols=0),
)
```

```{python}
sr_cmpr = vehdb.Comparator(lambda d, c: d[:, c], no_styling=True)
dataset_names = "accdb Python".split()  # Must sort with "diff" column.
```

```{python}
## Report PROP differences
#
#     ACCDB,  PYALGO
equivalent_columns = [
    ("Description", None),
    ("test_mass", None),
    ("kerb_mass", None),
    ("vehicle_class", "wltc_class"),
    #("pmr_km", "pmr"),
    ("f_dsc_req", "f_downscale"),
    ("v_max", "v_max"),
    ("n_max1", "n95_high"),
    #("???", "is_n_lim_vmax")
]

cdf = sr_cmpr.compare((p1.stack(), p2.stack()), equivalent_columns, dataset_names)
## Workaround qgrid's hate for hierarchical-columns:
#  https://github.com/quantopian/qgrid/issues/18#issuecomment-149321165
cdf.columns = [' '.join(col).strip() for col in cdf.columns.values]

display(vehdb.grid(cdf, fitcols=False, cwidth=100),)
# with pd.option_context('max_rows', 130):
#     display(cdf)
```

```{python}
# Available CYCLE columns
print(columnize(list(c1.columns), displaywidth=160))
print(columnize(list(c2.columns), displaywidth=160))
```

```{python}
cmpr = vehdb.Comparator(lambda d, c: d.loc[idx[:, c]])
```

```{python}
## Report CYCLE-MEAN differences
#
# # Vehicles with DOWNSCALE discrepancies
# veh_nums = [7, 19, 20, 33, 35, 43, 44, 56, 59, 66]
# veh_nums += [82, 88, 91, 99, 100, 101, 112, 113, 114]
# # UNCOMMENT next line to FETCH new vehicles.
p1, c1, p2, c2 = load_accdb_and_python_datasets()
equivalent_series = [
    ("v_orig", "v_cycle"),
    ("v_downscale", "v_target"),
    #("a", "a_target"),
    #("P_tot", "p_required"),
    #("P_max", "p_available"),
    ("g_max", "g_max0"),
    #("gear", "gears"),
   #("nc", "n"),
]

c2.columns = wio.flatten_columns(c2.columns)

cols1, cols2 = zip(*equivalent_series)
cols1, cols2 = list(cols1), list(cols2)
## Concat props to col-aggregates & convert prop-cols to numerics
cc1 = pd.concat((p1.infer_objects(), c1[cols1].abs().mean(level=0)), axis=1)
cc2 = pd.concat((p2.infer_objects(), c2[cols2].abs().mean(level=0)), axis=1)

equivalent_props = [
    ("Description", None),
    ("vehicle_class", 'wltc_class'),
    ("pmr_km", None),
    ("no_of_gears", None),
    ("f_dsc_req", "f_downscale"),
    ("v_max", "v_max"),
    ("n_vmax", "n_vmax"),
    ('gear_v_max', 'g_vmax'),
    ("n_max1", "n_max1"),
    ("n_max2", "n_max2"),
    ("n_max3", "n_max3"),
    ("n_max", "n_max"),
]
display(cmpr.compare((cc1, cc2), equivalent_props + equivalent_series, dataset_names, describe=True))
```

```{python}
# Repeat, to compare while coding.
display(cmpr.compare((cc1, cc2), equivalent_props + equivalent_series, dataset_names, describe=True))
```

AccDB vehicles: 42, 46, 52, 53 & 90 have broken `v_max`, 48 has broken `wot(ASM)`.

```{python}
known_bads = set(wio.veh_names([42, 46, 48, 52, 53, 90]))
display(cmpr.compare((cc1, cc2), equivalent_props + equivalent_series, dataset_names).set_properties(subset=(known_bads, idx[:]), color='red'))
```

## Compare a vehicle from AccDB <-->PyAlgo *interactively*

```{python}
case_loaded = [None, None]
def _load_interactive_case(
    case_name,
    # increase vertical seperation between flags (but do not exceed max(V))
    flag_mul=2,
):
    accdb_cycle = c1.loc[case_name].copy()
    accdb_gears = [c for c in accdb_cycle.columns if c.startswith('Ind_g')]

    cycle = c2.loc[case_name].dropna(how="all", axis=1).copy()
    
    ## Scale each flag into a different value, to plot separatly, and
    #  to plot in the same axis as V
    #  (bc when plotting flags in `secondary_y`, grid is not working)
    #

    all_flags = [c for c in cycle.columns if c.startswith("ok_")]
    ok_flags = [c for c in all_flags if not c.startswith("ok_gear/")]
    flag_count = len(ok_flags)
    ok_flags = cycle.loc[:, ok_flags].copy()

    ok_gears = [c for c in all_flags if c.startswith("ok_gear/")]
    gear_count = len(ok_gears)
    ok_gears = cycle.loc[:, ok_gears]

    ok_flags[ok_flags < 0] = np.NAN  # Restore NANFLAG --> NAN
    ok_flags = ok_flags * (np.arange(flag_count) + 1) * flag_mul
    ok_gears = ok_gears * (np.arange(gear_count) + flag_count + 1) * flag_mul

    cycle.columns = wio.inflate_columns(cycle.columns)
    ok_flags.columns = wio.inflate_columns(ok_flags.columns)
    ok_gears.columns = wio.inflate_columns(ok_gears.columns)

    return cycle, ok_flags, ok_gears, accdb_cycle, accdb_gears

def load_load_interactive_case(
    case_name,
    # increase vertical seperation between flags (but do not exceed max(V))
    flag_mul=2,
):
    if case_loaded[0] == case_name:
        cycle_data = case_loaded[1]
    else:
        cycle_data = _load_interactive_case(case_name)
        case_loaded[0] = case_name
        case_loaded[1] = cycle_data
    return cycle_data

#cycle, ok_flags, ok_gears, accdb_cycle, accdb_gears = load_load_interactive_case('v001')
# ok_flags.columns, ok_gears.columns
```

```{python}
from ipywidgets import (
    interact,
    interactive,
    interactive_output,
    fixed,
    interact_manual,
    widgets,
)
from IPython.display import clear_output

def grid(df):
    """Display a dynamic grid if given `df` too long. """
    if all(a < b for a, b in zip(df.shape, (120, 120))):
        with pd.option_context('display.max_rows', 121, 'display.max_columns', 121):
            display(df)
    else:
        display(vehdb.grid(df, fitcols=False))
    
init_zoom = 55.0
init_pan = 30.40
max_zoom = 72.0

Case = widgets.SelectionSlider(options=list(c2.index.levels[0]), description="Case")
Gear = widgets.SelectionSlider(options=["g1"], description="Gear")
Zoom = widgets.FloatSlider(
    init_zoom, min=1.0, max=max_zoom, step=1.0, description="Zoom"
)
Pan = widgets.FloatSlider(init_pan, min=0.0, max=max_zoom, step=0.4, description="Pan")
AccdbSignals = widgets.SelectMultiple(rows=7, description="AccDB signals")
IsAccdbGears = widgets.Checkbox(True, description="Plot AccDB Gears?")
AxisScenes = widgets.Select(
    options=[
        ## (abel, caseno, zoom, pan, desc)
        ("Dive@764: 1st gear too short", "v001, 45.0, 30.40, A"),
        ("Dive@903: 1st gear not reached", "v001, 45.0, 36.4, B"),
    ],
    description="Scenes",
    rows=7,
)
AxisScenes.layout.width = "auto"
Desc = widgets.Textarea(disabled=True)
Desc.layout.width = "24"
Desc.layout.height = "7em"
Selections = widgets.HBox(
    [Case, Gear, Zoom, Pan, AccdbSignals, IsAccdbGears, AxisScenes, Desc]
)
Selections.layout.width = "90%"
Selections.layout.flex_flow = "row wrap"
# Selections.layout.justify_content = "flex-start"
BadsGrid = widgets.Output()
PyAlgoGrid = widgets.Output()
AccDBGrid = widgets.Output()
outs = [BadsGrid, PyAlgoGrid, AccDBGrid]

Tab = widgets.Tab()
Tab.children = [BadsGrid, PyAlgoGrid, AccDBGrid]
for i, title in enumerate(
    ("DiffGear samples", "PyAlgo", "AccDB")
):
    Tab.set_title(i, title)

def display_diff_gears(pyalgo, accdb):
    pyalgo.columns = wio.flatten_columns(pyalgo.columns)
    merged = pd.concat((pyalgo, accdb), axis=1, keys=('pyalgo', 'accdb'))
    merged.columns = wio.flatten_columns(merged.columns)
    grid(merged)

def display_pyalgo(pyalgo, accdb):
    pyalgo.columns = wio.flatten_columns(pyalgo.columns)
    grid(pyalgo)

def display_accdb(pyalgo, accdb):
    grid(accdb)

out_specs = [
    (BadsGrid, display_diff_gears),
    (PyAlgoGrid, display_pyalgo),
    (AccDBGrid, display_accdb),
]

#: Updated by *interact* function, for display functions to read them
results = [None, None]

def update_tab_contents(change):
    if change.new is None:
        return
    out, func = out_specs[change.new]
    has_content = bool(out.get_state()['outputs'])
    if not has_content:
        with out:
            func(*results)

Tab.observe(update_tab_contents, names="selected_index")


Gui = widgets.VBox([Selections, Tab])


def update_valid_accdb_columns(change):
    case_name = Case.value
    _, _, ok_gears, accdb_cycle, _ = load_load_interactive_case(case_name)

    Gear.options = ok_gears.columns.levels[1]
    accdb_columns = [
        c
        for c in accdb_cycle.select_dtypes(exclude=[np.object])
        if not c.startswith("Ind_g")
    ]
    AccdbSignals.options = accdb_columns


Case.observe(update_valid_accdb_columns, names="value")
update_valid_accdb_columns(None)


def apply_axis_scene(change):
    Case.value, Zoom.value, Pan.value, Desc.value = re.split(r"[ ,]+", AxisScenes.value)

AxisScenes.observe(apply_axis_scene, names="value")


_existing_figs = set(plt.get_fignums())
fig = plt.figure(num="Vehicle AccDB <--> PyAlgo comparison", figsize=(20, 8))
## Hack, or else, double fig the 1st time this cell runs.
if fig.number in _existing_figs: 
    display(fig.canvas)
    fig.clear()

ax = plt.subplot()
ax2 = ax3 = None

def plot_gear_flags(case, gear, zoom, pan, accdb_signals, is_accdb_gears):
    global ax2, ax3

    ax.clear()
    if ax2:
        ax2.clear()
    if ax3:
        ax3.clear()

    cycle, ok_flags, ok_gears, accdb_cycle, accdb_gears = load_load_interactive_case(
        case
    )

    clen = len(cycle)
    viewlen = int(clen / zoom)
    offset = int(pan * (clen - viewlen) / max_zoom)
    scale = idx[offset : offset + viewlen]

    cycle = cycle.loc[scale]
    accdb = accdb_cycle.loc[scale]
    
    ## Clean tabs if caseno/pan/zoom have changed.
    #
    if not cycle.equals(results[0]):
        Tab.selected_index = None
        for out in outs:
            with out:
                clear_output()

    results[0] = cycle
    results[1] = accdb

    ok_flags = ok_flags.loc[:, idx[:, gear]].iloc[scale]
    ok_gears = ok_gears.loc[scale]

    cycle["v_cycle"].plot.line(ax=ax, linewidth=4)
    if not ok_flags.empty:
        ok_flags.plot.line(ax=ax, linewidth=2)
    ok_gears.plot.line(ax=ax, linewidth=3)

    ax2 = pd.concat((cycle["g_max0"], accdb["g_max"]), axis=1).plot.line(
        ax=ax, linewidth=3, style=["b-", "c:"], secondary_y=True
    )

    if is_accdb_gears:
        accdb_gears = accdb.loc[:, accdb_gears] * (np.arange(len(accdb_gears)) + 1)
        accdb_gears[accdb_gears == 0] = np.NAN
        accdb_gears = accdb_gears.dropna(how="all", axis=1).fillna(0)
        ax2 = accdb_gears.plot.line(ax=ax, linewidth=2, linestyle="--", secondary_y=True)

    if accdb_signals:
        if not ax3:
            ax3 = ax.twinx()
        else:
            ax3.set_visible(True)
        ax3.spines["right"].set_position(("axes", 1.1))
        accdb = accdb_cycle[list(accdb_signals)] * (np.arange(len(accdb_signals)) + 1)
        ax2 = accdb.loc[scale].plot.line(ax=ax3, linewidth=2, linestyle=":")
    elif ax3:
        ax3.set_visible(False)

    if ax2:
        ax2.grid(True, axis="both", which="both")
    ax.grid(True, axis="both", which="both")

    fig.tight_layout()  # Re-tighten if ax3 has (diss)appeared.
    
display(Gui)

interactive_output(
    plot_gear_flags,
    {
        "case": Case,
        "gear": Gear,
        "zoom": Zoom,
        "pan": Pan,
        "accdb_signals": AccdbSignals,
        "is_accdb_gears": IsAccdbGears,
    },
)
```

# Museum

```{python}
## Is clutch-undefined only used for gear 1?  NO< also for g2.
display(c1.loc[c1.clutch=='undefined', 'gear'].value_counts())
#display(c1.loc[c1.clutch=='undefined', ['v', 'a', 'g_max', 'clutch']])
```

```{python}
# c2 = c2.loc[c2.index != 'v116']
# p2 = p2.loc[p2.index != 'v116']
# p2.to_excel('pyalgo_props-1.0.0.dev10.xlsx')
# c2.to_excel('pyalgo_cycles-1.0.0.dev10.xlsx')
```
