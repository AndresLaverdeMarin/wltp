#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright 2019 European Commission (JRC);
# Licensed under the EUPL (the 'Licence');
# You may not use this work except in compliance with the Licence.
# You may obtain a copy of the Licence at: http://ec.europa.eu/idabc/eupl
"""
formulae estimating `v_max` from wot

The `v_max` is found by the maximum gear where `p_avail` intersects `p_required`.
"""
import logging
from collections import namedtuple
from typing import List, Union

import numpy as np
import pandas as pd

from pandalone import mappings, pandata

from . import io as wio
from . import vehicle, engine, utils
from .invariants import v_decimals, v_step, vround

log = logging.getLogger(__name__)

#: Solution results of the equation finding the v-max of each gear:
#:   - v_max: in kmh, or np.NAN if not found
#:   - n_vmax: the engine speed producing v_max
#:   - g_vmax: the number (or the name) of the gear producing v_max
#:   - wot: intermediate curves for solving the equation
VMaxRec = namedtuple("VMaxRec", "v_max  n_vmax  g_vmax  wot")


def _find_p_remain_root(wot: pd.DataFrame) -> VMaxRec:
    """
    Find the velocity (the "x") where `p_remain` (the "y") down-crosses zero,
    
    rounded towards the part of wot where p_remain > 0
    (like MSAccess in e.g. `F new vehicle.form.vbs#L3273`)
    or v @ max p_wot, if p_remain is always positive.

    :param wot: 
        grid-interpolated df indexed by v with (at least): p_remain
    :return:
        a :class:`VMaxRec` with v_max in kmh or np.NAN
    """
    w = wio.pstep_factory.get().wot

    assert not wot.empty
    wot = wot.dropna(axis=0, how="any", subset=[w.p_remain]).copy()

    if (wot[w.p_remain] > 0).all():
        v_max = wot.index[-1]  # v @ max n
    else:
        v_max = np.NAN
        ## Zero-crossings of p_remain are marked as sign-changes,
        #  particularly interested in "down-crosses":
        #   -1: drop from positive to 0 (perfect match!)
        #   -2: drop from positive to negative
        wot[w.sign_p_remain] = np.sign(wot[w.p_remain])

        ## diff-periods:
        #   ofs=+1: diff with prev-element so zero-crossing is marked on high-index (after cross)
        #   ofs=-1: diff with next-element so zero-crossing is marked on low-index (before cross)
        #  (e.g. `F new vehicle.form.vbs#L3273`).
        #  - Multiplied to preserve sign of down-crossing, for inequality further below.
        #  - Apply `fillna()`` bc `diff()` leaves one period at head or tail.
        #
        offs = -1
        wot[w.zero_crosings] = offs * wot[w.sign_p_remain].diff(periods=offs).fillna(0)
        # ... search for down-crossings only.
        roots_head = wot.index[wot[w.zero_crosings] < 0]
        # ... and capture v @ lowest of them (where p_remain is either 0 or still positive)
        if roots_head.size > 0:
            v_max = roots_head[0]  # Plain rounding, alreaydy close to grid.
            assert v_max == vround(v_max), (v_max, vround(v_max))
            _i = wot.loc[roots_head[0] :, w.p_remain].iteritems()
            assert next(_i)[1] > 0 and next(_i)[1] <= 0, (
                "Solution is not the last positive p_remain:",
                roots_head[0],
                v_max,
                wot.loc[v_max - 5 * v_step : v_max + 5 * v_step, w.p_remain],
            )

    return VMaxRec(v_max, wot.loc[v_max, w.n], None, wot)


def _calc_gear_v_max(gear_gwot: pd.DataFrame, f0, f1, f2) -> VMaxRec:
    """
    The `v_max` for some gear `g` is the solution of :math:`0.1 * P_{avail}(g) = P_{road_loads}`.

    :param gear_gwot:
        grid-interpolated WOT for some gear, indexed by v with (at least): p_avail column (in kW),
        NOTE: the `p_vail` must have already been **reduced** by safety-margin,
        
        .. attention:: it appends columns in this dataframe.
        
    :return:
        a :class:`VMaxRec` namedtuple.

    """
    w = wio.pstep_factory.get().wot

    gear_gwot[w.p_resist] = vehicle.calc_road_load_power(gear_gwot.index, f0, f1, f2)
    gear_gwot[w.p_remain] = gear_gwot[w.p_avail] - gear_gwot[w.p_resist]
    return _find_p_remain_root(gear_gwot)


def calc_v_max(grid_wots: Union[pd.Series, pd.DataFrame], f0, f1, f2) -> VMaxRec:
    """
    Finds the maximum velocity achieved by all gears.

    :param grid_wots:
        a dataframe of wot columns indexed by a grid of rounded velocities,
        as generated by :func:`~engine.interpolate_wot_on_v_grid2()`, and
        augmented by `:func:`~engine.calc_p_avail_in_gwots()` (in kW).
    :return:
        a :class:`VMaxRec` namedtuple.
    """
    c = wio.pstep_factory.get().wot

    ng = len(grid_wots.columns.levels[0])

    def _package_wots_df(recs):
        ## Merge all index values into the index of the 1st DF,
        #  or else, themerged-df contains n-gear dupes in each index-value.
        #
        # first_df, *rest_dfs = gear_wot_dfs
        # full_index = np.unique(np.hstack(df.index for df in gear_wot_dfs))
        # first_df = first_df.reindex(full_index)
        # wots_df = pd.concat(
        #     [first_df] + rest_dfs,
        #     axis=1,
        #     join="inner",
        wots_df = pd.concat(
            [r.wot for r in recs],
            axis=1,
            keys=[wio.gear_name(r.g_vmax) for r in recs],
            names=["gear", "wot_item"],
            verify_integrity=True,
        )

        return wots_df

    def gear_gwot(gi):
        return grid_wots.loc[:, wio.gear_name(gi)].copy()

    ## Scan gears from top --> (top - 4) but stop at most on 2nd gear.
    #
    gears_from_top = list(reversed(range(1, ng + 1)))
    gears_to_scan = gears_from_top[:-1][:4]
    assert gears_from_top, ("Too few gear-ratios?", ng)

    recs = [
        _calc_gear_v_max(gear_gwot(gi), f0, f1, f2)._replace(g_vmax=gi)
        for gi in gears_to_scan
    ]

    gear_wots_df = _package_wots_df(recs)
    vmaxes = pd.Series(r.v_max for r in recs)
    vmax = vmaxes.max()
    if not np.isnan(vmax):
        ## Scan from the top, by the GTR.
        #
        for rec_vmax in recs[::-1]:
            if rec_vmax.v_max == vmax:
                return rec_vmax._replace(wot=gear_wots_df)
        assert False
    raise ValueError(
        "Cannot find v_max!\n  Insufficient power??",
        gear_wots_df.head(),
        grid_wots.head(),
    )
