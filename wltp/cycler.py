#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright 2013-2019 European Commission (JRC);
# Licensed under the EUPL (the 'Licence');
# You may not use this work except in compliance with the Licence.
# You may obtain a copy of the Licence at: http://ec.europa.eu/idabc/eupl
"""formulae for cyle/vehicle dynamics"""
import logging
from numbers import Number
from typing import Union

import numpy as np
import pandas as pd
from pandas.core.generic import NDFrame

from . import engine
from . import io as wio

Column = Union[NDFrame, np.ndarray, Number]
log = logging.getLogger(__name__)


def calc_acceleration(V: Column) -> np.ndarray:
    """
    Acordign to formula in Annex 2-3.1
    
    :return:
        in m/s^2

        .. Attention:: 
            the result in the last sample is NAN!
    
    """
    A = np.diff(V) / 3.6
    A = np.append(A, np.NAN)  # Restore element lost by diff().

    return A


def emerge_cycle(
    v_cycle: pd.Series,
    v_dsc: pd.Series,
    v_cap: pd.Series,
    gwots: pd.DataFrame,
    long_phase_duration: int,
    up_threshold: float,
) -> pd.DataFrame:
    """
    Initialize cycle with 3 velocities, wot interpolated on `v_cap`, and acc/dec phases.

    :param gwots:
        a dataframe indexed by rounded velocities, 
        as generated by :func:`~engine.calc_power_required()`.
    :param long_phase_duration:
        (positive) consider *at least* that many conjecutive samples as belonging 
        to a `long_{stop/acc/cruise/dec}` generated column, 
        e.g.::
        
                    v: [0,3,3,3,5,8,8,4,0,0,0]
            cruise(2): [0,1,1,1,0,1,1,0,0,0,0]

        if 0,unspecified (might break)

        Phase identifications adapted from: 
        https://datascience.stackexchange.com/a/22105/79324
    :param up_threshold:
        the acceleration threshold(-0.1389) for identifying n_min_drive_up/down sections, 
        defined in Annex 2-2.k
    
    """
    c = wio.pstep_factory.get().cycle

    assert (
        all((isinstance(i, pd.Series) for i in (v_cycle, v_dsc, v_dsc)))
        and isinstance(gwots, pd.DataFrame)
        and isinstance(long_phase_duration, int)
        and isinstance(up_threshold, float)
    ), locals()

    cycle = pd.DataFrame(
        {c.t: v_cycle.index, c.v_cycle: v_cycle, c.v_downscale: v_dsc, c.v_cap: v_cap}
    ).set_index(c.v_cap, drop=False)
    V = cycle[c.v_cap]

    cycle[c.a_cap] = calc_acceleration(V)
    A = cycle[c.a_cap]

    cycle[c.run] = V >= 1
    RUN = cycle[c.run]

    def make_long_phase_mask(col):
        first_value = col.iloc[0]  # Ignore diff before 1st sample.
        grouper = (col != col.shift(fill_value=first_value)).cumsum()
        # NOTE: git warns: pandas/core/indexes/base.py:2890: FutureWarning:
        # elementwise comparison failed; returning scalar instead,
        # but in the future will perform elementwise comparison
        return col & col.groupby(grouper).transform("count").gt(long_phase_duration - 1)

    cycle[c.stop] = ~RUN
    cycle[c.stop_long] = make_long_phase_mask(cycle[c.stop])
    cycle[c.acc] = RUN & (A > 0)
    cycle[c.acc_long] = make_long_phase_mask(cycle[c.acc])
    cycle[c.cruise] = RUN & (A == 0)
    cycle[c.cruise_long] = make_long_phase_mask(cycle[c.cruise])
    cycle[c.dec] = RUN & (A < 0)
    cycle[c.dec_long] = make_long_phase_mask(cycle[c.dec])
    cycle[c.up] = A > up_threshold

    ## Mark start from standstill, Annex 2-3.2 about.
    cycle[c.init] = (V == 0) & (A == 0) & (A.shift(-1) != 0)

    cycle.columns = pd.MultiIndex.from_product(
        (cycle.columns, ("",)), names=("item", "gear")
    )
    gwots = gwots.reindex(V).swaplevel(axis=1).sort_index(axis=1)
    cycle = pd.concat((cycle, gwots), axis=1, sort=False)
    cycle = cycle.set_index(c.t, drop=False)

    return cycle


def cycle_add_p_avail_for_gears(cycle: pd.DataFrame, ng, SM) -> pd.DataFrame:
    """
    
    :param cycle:
        a  df with 2-level multindex columns, having at least ('p', 'g1') & ('ASM', 'g1'))
        for gears 1 to `ng`.`
    """
    w = wio.pstep_factory.get().wot

    for gear in range(1, ng + 1):
        gear = wio.gear_name(gear)
        cycle.loc[:, (w.p_avail, gear)] = engine.calc_p_available(
            cycle.loc[:, (w.p, gear)], cycle[(w.ASM, gear)], SM
        )

    return cycle


def flatten_cycle_columns(columns, sep="."):
    def join_column_names(name_or_tuple):
        if isinstance(name_or_tuple, tuple):
            return sep.join(n for n in name_or_tuple if n)
        return name_or_tuple

    return [join_column_names(names) for names in columns.to_flat_index()]


def inflate_cycle_columns(columns, sep=".", levels=2):
    def split_column_name(name):
        assert isinstance(name, str), ("Inflating Multiindex?", columns)
        names = name.split(sep)
        if len(names) < levels:
            nlevels_missing = levels - len(names)
            names.extend([""] * nlevels_missing)
        return names

    tuples = [split_column_name(names) for names in columns]
    return pd.MultiIndex.from_tuples(tuples, names=["gear", "item"])
