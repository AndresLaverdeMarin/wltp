#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright 2013-2019 European Commission (JRC);
# Licensed under the EUPL (the 'Licence');
# You may not use this work except in compliance with the Licence.
# You may obtain a copy of the Licence at: http://ec.europa.eu/idabc/eupl
"""formulae for cyle/vehicle dynamics"""
import dataclasses
import itertools as itt
import logging
from numbers import Number
from typing import Sequence as Seq
from typing import Union

import numpy as np
import pandas as pd
from pandas.core.generic import NDFrame

from . import engine
from . import io as wio

Column = Union[NDFrame, np.ndarray, Number]
log = logging.getLogger(__name__)


def calc_acceleration(V: Column) -> np.ndarray:
    """
    Acordign to formula in Annex 2-3.1

    :return:
        in m/s^2

        .. Attention::
            the result in the last sample is NAN!

    """
    A = np.diff(V) / 3.6
    A = np.append(A, np.NAN)  # Restore element lost by diff().

    return A


class CycleBuilder:
    ## Default `safety_margin` redundant here, but facilitates test code.
    SM: float = 0.1
    multi_column_separator: str = "."

    #: The instance that is built.
    cycle: pd.DataFrame
    #: A column within `cycle` to use in subsequent calculations.
    V: pd.Series
    #: A column derived from `V`, also within `cycle`, to use in subsequent calculations.
    A: pd.Series

    def __init__(self, *velocities: pd.Series, **kwargs):
        """
        Initialize :ivar:`cycle` with the given velocities and acceleration of the last one.

        :param velocities:
            *named* series, e.g. from :func:`~datamodel.get_class_v_cycle()`,
            all sharing the same time-index  The last one is assumed to be the
            "target" velocity for the rest of the cycle methods.
        """
        c = wio.pstep_factory.get().cycle

        assert velocities and all(
            (isinstance(i, pd.Series) and i.name and not i.empty for i in velocities)
        ), ("Null/empty inputs:", locals())

        vars(self).update(kwargs)

        ## Ensure time (index of velocities) is the 1st column.
        cycle = pd.DataFrame(
            dict([(c.t, velocities[0].index), *((v.name, v) for v in velocities)])
        )
        V = cycle.iloc[:, -1]
        cycle = cycle.set_index(c.t, drop=False)

        cycle[c.a] = calc_acceleration(V)

        self.cycle = cycle
        self.V = V
        self.A = cycle[c.a]

    def add_wots(self, gwots: pd.DataFrame):
        """
        Adds the `gwots` joined on the ``v_cap`` column of the `cycle`.

        :param gwots:
            a dataframe of wot columns indexed by a grid of rounded velocities,
            as generated by :func:`~engine.interpolate_wot_on_v_grid2()`, and
            augmented by `:func:`~engine.calc_p_avail_in_gwots()`.

        """
        c = wio.pstep_factory.get().cycle
        cycle = self.cycle

        assert all(
            (isinstance(i, pd.DataFrame) for i in (cycle, gwots))
        ) and isinstance(gwots, pd.DataFrame), locals()

        gwots = gwots.reindex(self.V).swaplevel(axis=1).sort_index(axis=1)
        cycle = pd.concat((cycle.set_index(self.V), gwots), axis=1, sort=False)
        cycle = cycle.set_index(c.t, drop=False)

        self.cycle = cycle

    def flatten_columns(self, columns):
        sep = self.multi_column_separator

        def join_column_names(name_or_tuple):
            if isinstance(name_or_tuple, tuple):
                return sep.join(n for n in name_or_tuple if n)
            return name_or_tuple

        return [join_column_names(names) for names in columns.to_flat_index()]

    def inflate_columns(self, columns, levels=2):
        sep = self.multi_column_separator

        def split_column_name(name):
            assert isinstance(name, str), ("Inflating Multiindex?", columns)
            names = name.split(sep)
            if len(names) < levels:
                nlevels_missing = levels - len(names)
                names.extend([""] * nlevels_missing)
            return names

        tuples = [split_column_name(names) for names in columns]
        return pd.MultiIndex.from_tuples(tuples, names=["gear", "item"])

    def flat(self) -> pd.DataFrame:
        """return the :ivar:`cycle` with flattened columns"""
        cycle = self.cycle.copy()
        cycle.columns = self.flatten_columns(cycle.columns)
        return cycle


@dataclasses.dataclass
class CycleMarker:
    """Identifies conjecutive truths in series"""

    #: The vehicle is stopped when its velocity is below this number (in kmh),
    #: by Annex 2-4 this is 1.0 kmh.
    running_threshold: float = 1.0

    #: (positive) consider *at least* that many conjecutive samples as
    #: belonging to a `long_{stop/acc/cruise/dec}` generated column,
    #: e.g. for ``phase_repeat_threshold=2`` see the example in :func:`_identify_conjecutive_truths()`.
    #: if 0,unspecified (might break)
    phase_repeat_threshold: int = 2

    #: the acceleration threshold(-0.1389) for identifying n_min_drive_up/down phases,
    #: defined in Annex 2-2.k
    up_threshold: float = -0.1389

    def _identify_conjecutive_truths(
        self, col: pd.Series, right_edge: bool
    ) -> pd.Series:
        """
        Dectect phases with a number of conjecutive trues above some threshold.

        :param col:
            a bolean series
        :param right_edge:
            when true, the `col` includes +1 sample towards the end

        >>> cycle = pd.DataFrame({
        ...          'v': [0,0,3,3,5,8,8,8,6,4,5,6,6],
        ...      'accel': [0,0,0,1,1,1,0,0,0,1,1,1,0],
        ...     'cruise': [0,0,0,0,0,1,1,1,0,0,0,0,0],
        ...      'decel': [0,0,0,0,0,0,0,1,1,1,0,0,0],
        ... })

        >>> A = (-cycle.v).diff(-1)  # GTR's acceleration definition
        >>> def phase(cond):
        ...     return cycler._identify_conjecutive_truths((cycle.v > 0) & cond, True, 2).astype(int).to_list()
        >>> assert phase(A > 0) == cycle.accel
        True
        >>> assert phase(A == 0) == cycle.cruise
        True
        >>> assert phase(A < 0) == cycle.decel
        True

        Adapted from: https://datascience.stackexchange.com/a/22105/79324
        """
        grouper = (col != col.shift()).cumsum()
        # NOTE: git warns: pandas/core/indexes/base.py:2890: FutureWarning:
        # elementwise comparison failed; returning scalar instead,
        # but in the future will perform elementwise comparison
        col &= col.groupby(grouper).transform("count").ge(self.phase_repeat_threshold)
        if right_edge:
            col |= col.shift()
        return col

    def add_phase_markers(
        self, cycle: pd.DataFrame, V: pd.Series, A: pd.Series
    ) -> pd.DataFrame:
        """
        Adds accel/cruise/decel/up phase markers into the given cycle,

        based `V` & `A` columns of a cycle generated by :func:`emerge_cycle()`.
        """
        c = wio.pstep_factory.get().cycle

        assert all(i is not None for i in (cycle, V, A)), (
            "Null in input:",
            cycle,
            V,
            A,
        )

        ## Mark start from standstill, Annex 2-3.2 about.
        cycle[c.init] = (V == 0) & (A == 0) & (A.shift(-1) != 0)

        ## Annex 2-4
        #
        cycle[c.run] = V >= self.running_threshold
        RUN = cycle[c.run]
        #
        def phase(cond):
            return self._identify_conjecutive_truths(RUN & cond, right_edge=True)

        #
        cycle[c.stop] = ~RUN
        cycle[c.accel] = phase(A > 0)
        cycle[c.cruise] = phase(A == 0)
        cycle[c.decel] = phase(A < 0)

        ## Annex 2-2.k (n_min_drive).
        cycle[c.up] = phase(A >= self.up_threshold)

        cycle.columns = pd.MultiIndex.from_product(
            (cycle.columns, ("",)), names=("item", "gear")
        )

        return cycle


def calc_allowed_n(cycle, ng: int, n_max1, n_max2, n_max3, nmins: engine.NMinDrives):
    """
    Translating conditions in the Annex 2: 2.k, 3.2, 3.3 & 3.5:

    ```
    (0) v < 1                     : g = 0, n = n_idle               # 3.2, but start-from_standstill
    (p) gear  >  2                : p_avail >= p_req                # 3.5
    (a) gear  <  g_v_max          : n_min  ≤  n  ≤  n95_max         # 3.3, n_min by 2.k
    (b)          g_v_max  ≤  gear : n_min  ≤  n  ≤  n_max_cycle     # 3.3, n_min by 2.k
    (c) gear 1                    : always, clutch if n < n_idle    # 3.3

    ```
    """
    d = wio.pstep_factory.get()
    c = wio.pstep_factory.get().cycle
    gnames = wio.gear_names(range(1, ng + 1))

    def two_level_index(item: str, gears: Seq[int]):
        gnames2 = [gnames[i] for i in gears]
        return pd.MultiIndex.from_tuples(itt.product((item,), gnames2))

    ## (p) rule
    #
    p_req = cycle["p_req"].to_frame()
    p_avail = cycle["p_avail"].sort_index(axis=1)
    p_ok = p_avail.fillna(0).values >= p_req.fillna(0).values
    ## 1st gear always p_capable
    p_ok[:, 0] = True
    ## Append flags into cycle
    #
    new_columns = two_level_index(c.p_ok, range(ng))
    p_ok_df = pd.DataFrame(p_ok, columns=new_columns)
    cycle = pd.concat((cycle, p_ok_df), axis=1)

    ## (a) rule
    #
