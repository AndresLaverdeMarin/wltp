# WLTP
UNECE's WLTP reference implementation in Python

[TOC]

## Contents
- Python code implementing the WLTP algorithm.
- The original files of the algo (document & MSAccess db).
- Notebooks to process the vehicle data, build HDF5-dbm launch the algo, etc::

      CarsDB-msaccess.ipynb   populate h5db with Heinz test-car input & output 
      CarsDB-phase1a.ipynb    populate h5db with results from the old python code
      CarsDB-compare.ipynb    print comparison results for cars in the h5db
      HDF5-APIh-help.ipynb    list usefull HDF5 methods
      nbutils.py              support code for the above notebooks
      WltpCars.h5             the h5db where all data are stored
      
> **Note:**
> It is the `.Rmd` files that are stored in the git-repo of this project;
> these aresynced  automatically with `.ipynb` notebooks byt the *jupytext*
> jupyter-lab extension.


## HDF5
Heinz Steven has implemented the original reference algorithm in the [`WLTP_GS_calculation_15032019_for_prog_code_subgroup.accdb`](./WLTP_GS_calculation_15032019_for_prog_code_subgroup.accdb) *MSAccess* database.
The MSAccess database facilitated the development & execution of the algorithm 
by storing any and all data needed during those phases.

To substitute those facilities i used the *pandas*+*HDF5* file-format to store data, 
peristently, across code runs.

- Help on `pandas` HDF5 facilities: https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#io-hdf5
- Help on the underlying `tables` library: https://www.pytables.org/
- Use []`vitables` GUI application](http://vitables.org/Screenshots/)
  to inspect the file (install it with: `conda install vitables`). 
- All major API methods of those libraries are listed  at the top 
  of the `CarsDB.ipynb` notebook.

### HDF5 Tree
```
vehicles/
    +--v001/
    |   +--props          (series) all kv-pairs from input/specs + SM, ASM
    |   +--pwot           (df) a single-column df(wot) indexed by n
    |   +--out1
    |   |   +--cycle      (df) cycle-run generated by HeinzDb
    |   |   +--props      (series) scalar inputs & outputs generated by HeinzDb
    |   |
    |   +--out2           (df) results generated by Python
    |       +--cycle      (df) cycle-run generated by Python 
    |       +--props      (series) scalar outputs generated by Python
    |
    +--v002/
        ...
```

## Recreate this Jupyter server
This server runs on a *conda* environment.  
All installed dependencies are kept in the `./environment.yaml` file,

> **Tip:**
> Maintain the env-file by running this terminal command after any programm (un)install::
>     
>     conda env export -n jupyter > environment.yaml 

To reproduce this server:

1. recreate the conda-env::

  ```bash
  $ conda env create -f environment.yaml
  ```

2. then ensure `qgrid` is properly installed for *jupyter lab*,
  by following [the instructions](https://github.com/quantopian/qgrid#installation)
  
  Optionally [install `jupytext`](https://github.com/mwouts/jupytext) if you want 
  to commit changes into this project's git-repo.

3. Finally launch it with:

  ```bash
  $ jupyter lab
  ```


## Code to extract data from MSAccess

in case it is needed in the future
...but cannot run in this server bc `pyodbc` lib cannot runs on *Linux* :-( 

```python
## Can run only on WINDOWS only!!
#
import pyodbc

def mdb_connect(db_file, user='admin', password = '', old_driver=False):
    """
    :param db_file:
        must be an absolute path
    """
    driver_ver = '*.mdb'
    if not old_driver:
        driver_ver += ', *.accdb'

    odbc_conn_str = ('DRIVER={Microsoft Access Driver (%s)}'
                     ';DBQ=%s;UID=%s;PWD=%s' %
                     (driver_ver, db_file, user, password))

    return pyodbc.connect(odbc_conn_str)

fname='WLTP_GS_calculation_15032019_for_prog_code_subgroup.accdb'
conn = mdb_connect(fname)
crsr = conn.cursor()

print([i.table_name for i in crsr.tables(tableType='TABLE')]
print([i.column_name for i in crsr.columns('gearshift_table_all')]
```

## Questions to Heinz
- How to etrapolate PWot?  eg. when `min(pwot[n]` > `n_idle`?
